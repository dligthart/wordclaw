[{"body":"## Summary\n`webhooks` in GraphQL Query is not wrapped with `withPolicy`, unlike adjacent privileged resolvers.\n\n## Evidence\n`src/graphql/resolvers.ts`:\n- `webhooks: async ...` at `:604` directly executes `listWebhooks(getDomainId(context))`.\n- Neighbor resolver `webhook` correctly uses `withPolicy('webhook.list', ...)` at `:615`.\n\n## Impact\n- Principals lacking webhook-specific privileges can still enumerate webhook endpoints for their domain through GraphQL.\n- Scope model inconsistency between GraphQL operations.\n\n## Recommended fix\n- Wrap `webhooks` with `withPolicy('webhook.list', () => ({ type: 'system' }), ...)`.\n- Add tests ensuring non-admin/non-webhook principals are denied.\n\n## Priority\nMedium\n","number":107,"title":"Security: GraphQL webhooks query bypasses policy/scope checks"},{"body":"## Summary\nWebhook URL validation currently only checks that `new URL(url)` succeeds. This allows callbacks to internal/private network targets and cloud metadata endpoints.\n\n## Evidence\n- URL validation only parses syntax:\n  - `src/api/routes.ts:169-176`\n  - `src/graphql/resolvers.ts:275-282`\n  - `src/mcp/server.ts:105-113`\n- Delivery performs direct server-side fetch to user-controlled URL:\n  - `src/services/webhook.ts:74-82`\n\n## Impact\n- Server-side request forgery (SSRF): attacker can force outbound requests to:\n  - `127.0.0.1`, `localhost`, RFC1918 ranges, link-local, metadata services (`169.254.169.254`), etc.\n- May expose internal services or credentials depending on runtime environment.\n\n## Recommended fix\n- Strictly allow only `https://` URLs.\n- Deny private, loopback, link-local, multicast, and metadata IP ranges (after DNS resolution, not string match only).\n- Optionally enforce an allowlist of webhook hostnames.\n- Re-resolve and validate on each delivery to mitigate DNS rebinding.\n\n## Priority\nHigh\n","number":105,"title":"Security: Webhook registration permits SSRF to internal/metadata endpoints"},{"body":"## Summary\nWorkflow submission/decision paths do not fully enforce tenant ownership and reviewer authorization.\n\n## Findings\n1. `WorkflowService.submitForReview` does not verify that:\n- `workflowTransitionId` belongs to the same tenant.\n- `contentItemId` belongs to the same tenant.\n\n2. `WorkflowService.decideReviewTask` does not enforce assignee/role authorization before approving/rejecting a task.\n\n## Evidence\n`src/services/workflow.ts`:\n- Transition loaded globally: `:47-50` (`where(eq(workflowTransitions.id, workflowTransitionId))`)\n- Existing pending tasks closed by `contentItemId` only: `:69-71`\n- Content item status updated by `contentItems.id` only: `:84-86`\n- Decision authorization explicitly missing (comment): `:102-104`\n\n`src/api/routes.ts`:\n- `POST /api/content-items/:id/submit` passes user-controlled `workflowTransitionId` directly into service (`:2873-2879`).\n- `POST /api/review-tasks/:id/decide` relies on service authorization (`:2927-2932`).\n\n## Impact\n- A tenant can potentially submit/transition content outside intended boundaries if IDs are known.\n- Any principal with broad `content.write` can decide review tasks without being assignee/reviewer.\n\n## Recommended fix\n- In service layer, always join/filter by `domainId` for transition, task, and content item records.\n- Enforce assignee or required-role checks in `decideReviewTask` before state mutation.\n- Add negative tests for cross-tenant submission and unauthorized decisions.\n\n## Priority\nHigh\n","number":104,"title":"Security: Workflow review APIs allow unauthorized/cross-tenant state transitions"},{"body":"## Summary\nMultiple MCP tool handlers read/write records by global IDs without `domainId` filtering. In multi-tenant deployments this can leak or mutate data across domains.\n\n## Evidence\n`src/mcp/server.ts` examples:\n- Content type/item operations by ID without tenant filter:\n  - `:224-225` get content type by `contentTypes.id`\n  - `:267` update content type where `eq(contentTypes.id, id)`\n  - `:297` delete content type where `eq(contentTypes.id, id)`\n  - `:870`/`:891` content item lookups by `contentItems.id`\n  - `:910` update by `contentItems.id`\n  - `:1222`/`:1259` batch deletes by `contentItems.id`\n- Version/audit/payment reads not tenant scoped:\n  - `:1288-1290` content item versions by `contentItemId` only\n  - `:1426-1439` audit log listing without domain filter\n  - `:1467-1470` payment list without domain filter\n  - `:1490` payment lookup by ID only\n\n## Impact\n- Cross-tenant data exposure and modification via MCP interface.\n\n## Recommended fix\n- Apply `domainId` constraints (or joins) for all tenant-owned entities in MCP handlers.\n- Add multi-tenant MCP contract tests covering read/write isolation.\n\n## Priority\nHigh\n","number":110,"title":"Security: MCP tools bypass tenant boundaries with unscoped ID-based operations"},{"body":"## Summary\nL402 payment tracking stores nearly all request headers in DB, but only redacts `authorization` and `cookie`. `x-api-key` and other sensitive headers can be persisted.\n\n## Evidence\n`src/services/l402-config.ts`:\n- Headers are copied verbatim into `payments.details` with limited redaction:\n  - `:78-81` -> `{ ...headers, authorization: '[REDACTED]', cookie: '[REDACTED]' }`\n\n## Impact\n- API keys may be stored in plaintext in `payments.details`.\n- Any user/service with payment log access can exfiltrate credentials.\n- Increases blast radius of DB/log compromise.\n\n## Recommended fix\n- Do not store raw headers.\n- If telemetry is needed, store explicit safe allowlist (`user-agent`, minimal metadata) and drop all auth-like headers.\n- Add explicit redaction for `x-api-key`, `x-setup-token`, and any header containing `key`, `token`, `secret`, `authorization`, `cookie`.\n\n## Priority\nHigh\n","number":108,"title":"Security: Payment audit details persist raw request headers (including x-api-key)"},{"body":"## Summary\nSeveral REST endpoints do not apply `domainId` filtering, exposing data across tenants.\n\n## Affected endpoints\n- `GET /api/audit-logs`\n- `GET /api/payments`\n- `GET /api/content-items/:id/versions`\n\n## Evidence\n`src/api/routes.ts`:\n- Audit logs list omits domain scope:\n  - `:2605-2624` conditions do not include `auditLogs.domainId`\n  - `:2626-2641` count/select execute without tenant filter\n- Payments list omits domain scope:\n  - `:2690` total count from all `payments`\n  - `:2701-2704` list query from all `payments` without `domainId`\n- Content item versions endpoint omits domain scope:\n  - `:1727-1730` queries `contentItemVersions` by `contentItemId` only\n\n## Impact\n- Tenant A can enumerate Tenant B audit/payment metadata.\n- Tenant A can read version history for Tenant B content if IDs are known.\n\n## Repro sketch\n1. Create two domains with separate keys.\n2. Generate audit events/payments/content versions in domain B.\n3. Call endpoints above with domain A key.\n4. Observe domain B records in responses.\n\n## Recommended fix\n- Add `eq(<table>.domainId, getDomainId(request))` (or equivalent joins) to all list/read paths.\n- For `contentItemVersions`, join through `content_items` and filter on `content_items.domain_id`.\n- Add tenant isolation contract tests for these routes.\n\n## Priority\nHigh\n","number":103,"title":"Security: REST endpoints leak cross-tenant data (audit logs, payments list, content versions)"},{"body":"## Summary\nA large subset of GraphQL resolvers reads/writes by global IDs without scoping by `domainId`. In multi-tenant mode this enables cross-tenant access and mutation if an attacker knows or guesses IDs.\n\n## Impact\n- Cross-tenant data disclosure and tampering.\n- A tenant-scoped key can update/delete/rollback another tenant's content by ID.\n- Breaks tenant isolation guarantees.\n\n## Evidence (examples)\n`src/graphql/resolvers.ts`:\n- Content type update/delete are not domain-scoped:\n  - `:691` dry-run lookup by `contentTypes.id`\n  - `:701` update where `eq(contentTypes.id, id)`\n  - `:728` delete where `eq(contentTypes.id, id)`\n- Content item update/delete/rollback are not domain-scoped:\n  - `:969` existing item lookup by `contentItems.id`\n  - `:1002` tx current lookup by `contentItems.id`\n  - `:1021` update where `eq(contentItems.id, id)`\n  - `:1231` delete where `eq(contentItems.id, id)`\n  - `:1490` rollback current item lookup by `contentItems.id`\n  - `:1551` rollback update where `eq(contentItems.id, id)`\n- Version history lookup is not domain-scoped:\n  - `:523-529` `contentItemVersions` by `contentItemId` only\n\n## Repro sketch\n1. Create tenant A and tenant B with separate API keys.\n2. In tenant B, create content item `id=NN`.\n3. Query GraphQL as tenant A: `mutation { deleteContentItem(id: NN) { id message } }`.\n4. Mutation succeeds despite tenant mismatch.\n\n## Recommended fix\n- Enforce `domainId` in every GraphQL select/update/delete touching tenant data.\n- For `contentItemVersions`, join through `content_items` and filter by `content_items.domain_id`.\n- Add contract tests for cross-tenant denial on every GraphQL content mutation and version query.\n\n## Priority\nCritical\n","number":102,"title":"Security: GraphQL resolvers allow cross-tenant read/write via missing domain constraints (IDOR)"}]
